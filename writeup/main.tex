\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, siunitx, physics}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage[hidelinks]{hyperref}
\usepackage{float}
\usepackage{caption}

\geometry{margin=1in}

\title{4$\times$4 CMOS Array Multiplier}

%[insert title image]

\author{Krishna Karthikeya Chemudupati \and Adithya Selvakumar}
\date{November 2025}

\begin{document}
\maketitle

\newpage

\tableofcontents

\newpage

% ----------------------------------------------------
\section{Introduction and Background}



\newpage

% ----------------------------------------------------
\section{Baseline Design}



\newpage

% ----------------------------------------------------
\section{Baseline Functional Verification}



\newpage

% ----------------------------------------------------
\section{Baseline Delay Measurement}



\newpage

% ----------------------------------------------------
\section{Baseline Active Energy Measurement}



\newpage

% ----------------------------------------------------
\section{Baseline Leakage Energy Measurement}



\newpage

% ----------------------------------------------------
\section{Optimized Design}

\subsection{Worst Case Delay}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.92\linewidth]{writeup/figures/arraymult_criticalpath.png}
  \caption{Critical-path staircases in a 4×4 Braun array multiplier. X$_0$–X$_3$ are the N bits (multiplicand) and Y$_0$–Y$_3$ are the M bits (multiplier). Figure adapted from materials by Prof. Janakiraman Viraraghavan, IIT Madras.}
\end{figure}

\noindent
We analyze the 4×4 Braun (array) multiplier shown above. The multiplicand bits are X$_0$–X$_3$ (the N bits) and the multiplier bits are Y$_0$–Y$_3$ (the M bits). Each partial product x$_i$y$_j$ is generated by a static-CMOS AND gate, and these partial products are reduced by a regular grid of half adders (HAs) and full adders (FAs). Within a column, carries propagate downward; between columns, sums propagate leftward. The slow paths are the northeast-to-southwest staircases that begin at a right-edge partial product and alternate vertical carry hops with horizontal sum hops until they reach the lower-left outputs.

\paragraph{Delay primitives and convention}
We define three cell delays under the loading and drive conditions that match the tiled array:
\[
t_{\text{and}} \text{ for the partial-product AND,}\quad
t_{\text{carry}} \text{ for an HA/FA carry-out,}\quad
t_{\text{sum}} \text{ for an HA/FA sum-out.}
\]
In static-CMOS adders the sum network is built from XOR/XNOR structures that have larger logical effort and parasitic capacitance than the carry (majority / AND-OR) network, so typically
\[
t_{\text{sum}} > t_{\text{carry}}.
\]

\paragraph{Exciting the limiting staircase}
The worst transition is not the input vector that flips the most bits. It is the transition that (i) toggles a right-edge partial product and (ii) places each encountered adder in propagate mode (a$\oplus$b = 1 and ab = 0), forcing a newly injected carry to ripple through all stages along a staircase to the lower-left.

\paragraph{Counting hops on an M×N array}
For any such staircase in an M×N array, the stage counts are:
\[
\begin{aligned}
\text{carry hops}   &= (M-1) + (N-2),\\
\text{sum hops}     &= (M-1),
\end{aligned}
\]
plus the initial $t_{\text{and}}$ that launches the path. Therefore the generic array-multiplier timing is
\[
t_{\text{array}}(M,N) \;=\; \big[(M-1) + (N-2)\big]\,t_{\text{carry}}
\;+\; (M-1)\,t_{\text{sum}}
\;+\; t_{\text{and}}.
\]

\paragraph{Specialization to the 4×4 case}
With $M=N=4$ we obtain five carry hops and three sum hops:
\[
t_{\text{path}} \;=\; 5\,t_{\text{carry}} + 3\,t_{\text{sum}} + t_{\text{and}}.
\]
In the 4×4 topology the bottom-left FA drives two neighboring outputs: its carry is Z$_7$ and its sum is Z$_6$. The staircase counted above terminates at the sum of this FA, so
\[
\boxed{\,t_{Z_6} = 5\,t_{\text{carry}} + 3\,t_{\text{sum}} + t_{\text{and}}\,}.
\]
Because $t_{\text{sum}} > t_{\text{carry}}$ for static-CMOS FAs, Z$_6$ is slower than the otherwise identical staircase that would end at the carry output Z$_7$. Hence the worst-case delay of the 4×4 array ends at Z$_6$, not Z$_7$.

\paragraph{Implications}
Multiple staircases (such as CP$_1$ and CP$_2$ in the figure) have the same hop counts and are nearly iso-delay, so cell sizing must balance stage effort across the grid. Nevertheless, the decisive last stage is the sum network of the bottom-left FA that produces Z$_6$, and this stage should be weighted accordingly when sizing to minimize the overall worst-case delay.

\subsection{Schematics in Static CMOS}
\subsubsection{Full Adder (FA)}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.95\linewidth]{writeup/figures/staticcmos_fa_rabaey.png}
  \caption{Complementary static-CMOS full adder. Figure adapted from Rabaey.}
\end{figure}

\noindent
The full adder computes the carry-out $C_o$ and sum $S$ from inputs $A$, $B$, and $C_i$.  
We employ a complementary static-CMOS realization that shares intermediate logic between
the carry and sum paths. The logic is organized as
\[
C_o = AB + BC_i + AC_i \quad\text{(3-input majority)}, \qquad
S = ABC_i + C_o\,(A + B + C_i).
\]
The schematic implements these expressions with series–parallel $p$- and $n$-networks so that
each output is produced by static pull-up and pull-down paths, guaranteeing full-swing,
monotonic transitions and large noise margins.

\paragraph{Signal flow and stage counts}
The circuit is partitioned around an internal node $X$ that realizes the reorganized carry logic.
\begin{itemize}
  \item \textbf{Path to $C_o$ (two static stages).} A complex CMOS network first forms $X$,
  which captures the majority function. An output inverter then buffers $X$ to produce $C_o$.
  \item \textbf{Path to $S$ (three static stages).} The same $X$ is reused by a second
  static network that combines $X$ with $A$, $B$, and $C_i$ to generate a pre-sum node.
  A final inverter buffers this node to produce $S$.
\end{itemize}
Thus, $C_o$ emerges after two static stages and $S$ after three. While not ``single-stage''
at the pins, these are compact paths with low internal fanout and limited parasitic loading.

\paragraph{Why static CMOS over a bag of gates}
A gate-assembled FA (e.g., library XOR/AND/OR composition) typically yields a deeper chain:
$C_o$ commonly requires two XOR-class stages, and $S$ often traverses a sequence such as
XOR $\rightarrow$ NAND $\rightarrow$ NOT $\rightarrow$ NOR $\rightarrow$ NOT.
Each additional logic boundary adds logical effort and parasitic capacitance, inflating
end-to-end delay and degrading slews. The static-CMOS realization reduces the number of
boundaries, shares $X$ rather than duplicating heavy networks, and eliminates large internal
fanouts between discrete gates. Because both outputs are produced by complementary static
networks and then buffered, signals remain rail-to-rail and monotonic across many cascaded cells.

\paragraph{Fit for the array multiplier}
In the 4$\times$4 Braun array, the slow paths are the northeast-to-southwest staircases of adders,
and the measured worst case terminates at the sum output of the bottom-left FA ($Z_6$).
Replacing multi-gate chains with the compact static implementation shortens the effective
stage depth on these staircases and reduces internal parasitics, lowering the overall delay.

\noindent At the same time, static-CMOS robustness (no ratioing, no dynamic storage) ensures predictable
behavior when many FA cells are tiled: outputs do not droop through the grid, hazards are
suppressed by the static topologies and output inverters, and uniform polarity avoids the need
for multiple FA variants or extra inverters during integration.

\noindent
In summary, the Rabaey complementary static-CMOS FA provides a favorable speed–robustness tradeoff
for the multiplier: fewer and better stages than a bag-of-gates implementation, shared intermediate
logic that limits internal loading, and full-swing stability that holds when cascading many cells.

\subsubsection{Half Adder (HA)}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.43\linewidth]{writeup/figures/staticcmos_xor.png}\hfill
  \includegraphics[width=0.43\linewidth]{writeup/figures/staticcmos_nand.png}
  \caption{Static-CMOS XOR (left) for Sum and NAND (right) used with a following inverter for Carry. Figure adapted from Shakshat Virtual Lab, IIT Guwahati}
\end{figure}

\noindent
The half adder takes one-bit inputs $A$ and $B$ and produces outputs \textit{Sum} and \textit{Carry}. From the truth table,
\[
\text{Sum} = A \oplus B,
\qquad
\text{Carry} = A \cdot B = \overline{\mathrm{NAND}(A,B)}.
\]

\noindent
Implementation in complementary static CMOS is therefore direct:
\begin{itemize}
  \item \textbf{Sum path.} Realize $A \oplus B$ with a static-CMOS XOR gate. This is a single logic stage at the Sum pin with full-swing, monotonic behavior.
  \item \textbf{Carry path.} Realize $A \cdot B$ as a static-CMOS NAND followed by a static inverter: $\text{Carry}=\overline{\mathrm{NAND}(A,B)}$. This is two logic stages at the Carry pin (NAND then inverter), also full swing and monotonic.
\end{itemize}

\noindent
Unlike the full adder, there is no third input to exploit for algebraic sharing or logic reorganization; the minimal Boolean forms are already $A \oplus B$ and $A \cdot B$. Consequently, the “optimized” static-CMOS HA coincides with the baseline bag-of-gates realization: one XOR stage for Sum and a NAND+inverter pair for Carry. This keeps logic depth minimal for each output while retaining the robustness advantages of static CMOS (rail-to-rail levels, large noise margins, and predictable cascading behavior in the multiplier array).



\newpage

% ----------------------------------------------------
\section{Optimized Functional Verification}



\newpage

% ----------------------------------------------------
\section{Optimized Delay Measurement}



\newpage

% ----------------------------------------------------
\section{Optimized Active Energy Measurement}



\newpage

% ----------------------------------------------------
\section{Optimized Leakage Energy Measurement}



\newpage

% ----------------------------------------------------
\section{Summary of Optimization Process}



\newpage

% ----------------------------------------------------
\section{Summary Comparison of Baseline and Optimized Designs}



\newpage

% ----------------------------------------------------
\section{Conclusion}



\end{document}
